[{"/Users/abraham/Geometry-editor/src/index.js":"1","/Users/abraham/Geometry-editor/src/App.js":"2","/Users/abraham/Geometry-editor/src/Canvas.js":"3","/Users/abraham/Geometry-editor/src/Stuff.js":"4","/Users/abraham/Geometry-editor/src/Geometry.js":"5"},{"size":152,"mtime":1652461676684,"results":"6","hashOfConfig":"7"},{"size":3260,"mtime":1652465947476,"results":"8","hashOfConfig":"7"},{"size":4420,"mtime":1662987826309,"results":"9","hashOfConfig":"7"},{"size":1766,"mtime":1662992063957,"results":"10","hashOfConfig":"7"},{"size":6677,"mtime":1662992718792,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"1hrt06z",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"19","usedDeprecatedRules":"14"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22","usedDeprecatedRules":"14"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/abraham/Geometry-editor/src/index.js",[],["25","26"],"/Users/abraham/Geometry-editor/src/App.js",[],"/Users/abraham/Geometry-editor/src/Canvas.js",["27"],"import React, { useRef, useState, useEffect } from \"react\";\nimport { draw } from \"./Geometry\";\nimport { isNumeric, isColor } from \"./Stuff\";\nimport \"./styles.css\"\n\nexport default function Canvas(props) {\n  const [state, setState] = useState({\n    scale: 20,\n    dragging: false,\n    x: 0,\n    y: 0,\n    marginLeft: 0,\n    marginTop: 0,\n  });\n\n  const canvasRef = useRef();\n\n  function restartScale() {\n    setState((prev) => ({\n      ...prev,\n      scale: 20,\n      dragging: false,\n      x: 0,\n      y: 0,\n    }))\n  }\n\n  function prepareCanvas() {\n    const canvas = canvasRef.current\n    const ctx = canvas.getContext('2d')\n\n    ctx.clearRect(-state.marginLeft, -state.marginTop, canvas.width, canvas.height)\n\n    ctx.fillStyle = '#f6f6fc'\n    ctx.fillRect(-state.marginLeft, -state.marginTop, canvas.width, canvas.height)\n    ctx.rect(-state.marginLeft, -state.marginTop, canvas.width, canvas.height)\n\n    // if (props.showGrid) {\n    //   // ctx.fillStyle = drawGrid({ deltaX: state.scale, deltaY: state.scale, color: '#606060', scale: 100 })\n    //   // ctx.fill()\n\n    //   // ctx.fillStyle = drawGrid({deltaX: 1000, deltaY: 1000, color: 'black', scale: state.scale})\n    //   // ctx.fill()\n    // }\n  }\n\n  function drawObjects() {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n\n    // Draws all objects again\n    let currentColor = \"black\";\n    let showVertices = false;\n    props.objects.forEach((element) => {\n      let data = [...element];\n\n      if (isColor(data[0])) {\n        currentColor = data[0]\n        return;\n      }\n\n      if (currentColor === \"transparent\") {\n        return;\n      }\n\n      if (data.length === 1 && data[0] === \"showVertices\") {\n        showVertices = true;\n        return;\n      }\n\n      // Use some \"intelligence\" to know what's going on\n      if (isNumeric(data[0])) {\n        if (data.length >= 2 && isNumeric(data[1])) {\n          if (data.length >= 3 && isNumeric(data[2])) {\n            if (data.length >= 3 && isNumeric(data[3])) {\n              // 4 numeric values, so for me it is a 'poly' of 2 sides :D\n              data.unshift('poly')\n            } else {\n              // 3 numeric values, so for me it is a circle\n              data.unshift('circle')\n            }\n          } else {\n            // 2 numeric values, so for me it is a point\n            data.unshift('point')\n          }\n        } else {\n          // idk what is this\n        }\n      }\n\n      // They especify the type\n      if (data.length < 3)\n        return; // not ready yet \n\n      const type = data[0]\n      data.shift();\n\n      draw({\n        type: type,\n        ctx: ctx,\n        canvas: canvas,\n        data: data,\n        scale: state.scale,\n        defaultColor: currentColor,\n        showVertices: showVertices\n      });\n    });\n\n    ctx.restore();\n  }\n\n  useEffect(() => {\n    if (props.restartScale) {\n      restartScale();\n      props.restartScaleDone();\n    }\n    prepareCanvas();\n    drawObjects();\n  }, [\n    props.objects, props.restartScale,\n    state.dragging, state.scale,\n    state.x, state.y]);\n\n  function zoomInOut(event) {\n\n    const deltaScale = 0.01\n\n    setState((prev) => {\n      let newScale = prev.scale + event.deltaY * -deltaScale\n      newScale = Math.min(500, Math.max(1, newScale))\n\n      return ({\n        ...prev,\n        scale: newScale\n      })\n    })\n  }\n\n  function onMouseUp(event) {\n\n    setState((prev) => ({\n      ...prev,\n      dragging: false\n    }))\n  }\n\n  function onMouseMove(event) {\n\n    const canvas = canvasRef.current\n    const ctx = canvas.getContext('2d')\n\n    setState((prevState) => {\n      let curState = prevState\n\n      if (curState.dragging) {\n        let deltaX = event.clientX - prevState.x\n        let deltaY = event.clientY - prevState.y\n\n        curState.marginLeft += deltaX\n        curState.marginTop += deltaY\n        ctx.translate(deltaX, deltaY)\n\n        curState.x = event.clientX\n        curState.y = event.clientY\n      }\n\n      return ({\n        ...prevState,\n        ...curState\n      })\n    })\n  }\n\n  function onMouseDown(event) {\n\n    setState((prev) => ({\n      ...prev,\n      dragging: true,\n      x: event.clientX,\n      y: event.clientY,\n    }))\n  }\n\n  return (\n    <canvas\n      width=\"1000\" height=\"800\"\n      className=\"image\"\n      ref={canvasRef}\n      onWheel={zoomInOut}\n      onMouseDown={onMouseDown}\n      onMouseMove={onMouseMove}\n      onMouseUp={onMouseUp} />\n  );\n}","/Users/abraham/Geometry-editor/src/Stuff.js",["28"],"export function isNumeric(num) {\n  return !isNaN(num)\n}\n\nexport function isColor(x) {\n  let s = new Option().style\n  s.color = x\n  let test1 = s.color === x\n  let test2 = /^#[0-9A-F]{6}$/i.test(x)\n  return (test1 === true || test2 === true)\n}\n\nexport function isSpace(c) {\n  return (c === ' ') || (c === '\\t');\n}\n\nexport function divideByTokens(str) {\n  var result = [];\n  var last = \"\";\n  for (var i in str) {\n    var c = str[i];\n    if (isSpace(c)) {\n      if (last !== \"\") {\n        result.push(last);\n      }\n      last = \"\";\n    } else {\n      last += c;\n    }\n  }\n  if (last !== \"\") {\n    result.push(last);\n  }\n  return result;\n}\n\nfunction getRGB(v) {\n  var el = document.createElement(\"div\");\n  el.style[\"background-color\"] = v;\n  document.body.appendChild(el);\n\n  var style = window.getComputedStyle(el);\n  var color = style[\"backgroundColor\"];\n  document.body.removeChild(el);\n\n  return color;\n}\n\nfunction parseColor(color) {\n  var arr = [];\n  color.replace(/[\\d+\\.]+/g, function (v) {\n    arr.push(parseFloat(v));\n  });\n  return \"#\" + arr.slice(0, 3).map(toHex).join(\"\");\n}\n\nfunction toHex(int) {\n  var hex = int.toString(16);\n  return hex.length === 1 ? \"0\" + hex : hex;\n}\n\nexport function lightenColor(color, amt = 0, alpha = 0) {\n  if (color.charAt(0) !== '#') {\n    color = parseColor(getRGB(color));\n  }\n\n  let cur = color.charAt(0) === '#' ? color.substring(1, 7) : color;\n\n  let r = Math.max(Math.min(255, parseInt(cur.substring(0, 2), 16) + amt), 0);\n  let g = Math.max(Math.min(255, parseInt(cur.substring(2, 4), 16) + amt), 0);\n  let b = Math.max(Math.min(255, parseInt(cur.substring(4, 6), 16) + amt), 0);\n  let a = Math.round(alpha * 255);\n\n  let hex = `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n  if (a) {\n    hex += toHex(a);\n  }\n\n  return hex;\n}","/Users/abraham/Geometry-editor/src/Geometry.js",[],{"ruleId":"29","replacedBy":"30"},{"ruleId":"31","replacedBy":"32"},{"ruleId":"33","severity":1,"message":"34","line":120,"column":6,"nodeType":"35","endLine":123,"endColumn":22,"suggestions":"36"},{"ruleId":"37","severity":1,"message":"38","line":51,"column":22,"nodeType":"39","messageId":"40","endLine":51,"endColumn":23,"suggestions":"41"},"no-native-reassign",["42"],"no-negated-in-lhs",["43"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'drawObjects', 'prepareCanvas', and 'props'. Either include them or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.","ArrayExpression",["44"],"no-useless-escape","Unnecessary escape character: \\..","Literal","unnecessaryEscape",["45","46"],"no-global-assign","no-unsafe-negation",{"desc":"47","fix":"48"},{"messageId":"49","fix":"50","desc":"51"},{"messageId":"52","fix":"53","desc":"54"},"Update the dependencies array to be: [drawObjects, prepareCanvas, props, props.objects, props.restartScale, state.dragging, state.scale, state.x, state.y]",{"range":"55","text":"56"},"removeEscape",{"range":"57","text":"58"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"59","text":"60"},"Replace the `\\` with `\\\\` to include the actual backslash character.",[2975,3070],"[drawObjects, prepareCanvas, props, props.objects, props.restartScale, state.dragging, state.scale, state.x, state.y]",[973,974],"",[973,973],"\\"]