[{"/Users/abraham/Geometry-drawing-tool/src/index.js":"1","/Users/abraham/Geometry-drawing-tool/src/App.js":"2","/Users/abraham/Geometry-drawing-tool/src/Canvas.js":"3","/Users/abraham/Geometry-drawing-tool/src/Geometry.js":"4","/Users/abraham/Geometry-drawing-tool/src/Stuff.js":"5"},{"size":152,"mtime":1612217664607,"results":"6","hashOfConfig":"7"},{"size":2251,"mtime":1613871158947,"results":"8","hashOfConfig":"7"},{"size":4917,"mtime":1613873632064,"results":"9","hashOfConfig":"7"},{"size":6427,"mtime":1613873529174,"results":"10","hashOfConfig":"7"},{"size":1793,"mtime":1613868883136,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"1ydm6kb",{"filePath":"15","messages":"16","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"17","usedDeprecatedRules":"14"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"20","usedDeprecatedRules":"14"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"26","usedDeprecatedRules":"14"},"/Users/abraham/Geometry-drawing-tool/src/index.js",[],["27","28"],"/Users/abraham/Geometry-drawing-tool/src/App.js",["29","30","31","32","33"],"import React, { Component } from 'react';\nimport ReactDOM from \"react-dom\"\n\nimport Canvas from \"./Canvas\";\nimport { divideByTokens, isSpace } from \"./Stuff\";\nimport \"./styles.css\"\nimport \"./button.css\"\n\nclass App extends Component {\n  constructor() {\n    super()\n\n    this.state = {\n      objects: [],\n      showGrid: false,\n      restartScale: false,\n    }\n  }\n\n  getInput(event) {\n    this.setState(() => {\n      const text = event.target.value\n\n      const newObjects = text.split('\\n').map((line) => {\n        function isGood(c) {\n          if ('0' <= c && c <= '9')\n            return true;\n          if ('a' <= c && c <= 'z')\n            return true;\n          if ('A' <= c && c <= 'Z')\n            return true;\n          if (isSpace(c))\n            return true\n          return c == '.' || c == '-' || c == '+' || c == '#'\n        }\n\n        var cleanLine = \"\"\n        for (const c of line)\n          if (isGood(c))\n            cleanLine += c\n\n        const properties = divideByTokens(cleanLine)\n        console.log(properties)\n\n        return properties\n      })\n\n      return {\n        objects: newObjects\n      }\n    })\n  }\n\n  showGridButton(event) {\n    this.setState((prevState) => {\n      return {\n        showGrid: !prevState.showGrid\n      }\n    })\n  }\n\n  restartScale(event) {\n    this.setState({ restartScale: true })\n  }\n\n  restartScaleDone() {\n    this.setState({ restartScale: false })\n  }\n\n  render() {\n    return (\n      <div>\n        <div className=\"multi-button\">\n          <button>Geometry noob version</button>\n\n          <button onClick={this.restartScale.bind(this)} >\n            Restart scale\n          </button>\n\n          <button onClick={this.showGridButton.bind(this)}>\n            {this.state.showGrid ? 'Hide' : 'Show'} grid\n          </button>\n        </div>\n\n        <div>\n          <textarea\n            type=\"text\"\n            className=\"input\"\n            onChange={this.getInput.bind(this)}\n          >\n          </textarea>\n\n          <Canvas \n            objects={this.state.objects}\n            showGrid={this.state.showGrid}\n            restartScale={this.state.restartScale}\n            restartScaleDone={this.restartScaleDone.bind(this)} />\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default App;\n","/Users/abraham/Geometry-drawing-tool/src/Canvas.js",["34"],"import React, { Component } from \"react\";\nimport { drawText, drawGrid, drawPoint, drawLine, drawSegment, drawCircle, drawPolygon } from \"./Geometry\";\nimport { isNumeric } from \"./Stuff\";\nimport \"./styles.css\"\n\nclass Canvas extends Component {\n  constructor(props) {\n    super(props)\n    this.canvasRef = React.createRef()\n\n    this.state = {\n      scale: 20,\n      dragging: false,\n      x: 0,\n      y: 0,\n      marginLeft: 0,\n      marginTop: 0,\n    }\n\n    this.restartScale = this.restartScale.bind(this)\n  }\n\n  restartScale() {\n    console.log(\"Restart go to origin Canvas\")\n\n    this.setState(() => {\n      return {\n        scale: 20,\n        dragging: false,\n        x: 0,\n        y: 0,\n      }\n    })\n  }\n\n  prepareCanvas() {\n    const canvas = this.canvasRef.current\n    const ctx = canvas.getContext('2d')\n\n    ctx.clearRect(-this.state.marginLeft, -this.state.marginTop, canvas.width, canvas.height)\n\n    ctx.fillStyle = '#f6f6fc'\n    ctx.fillRect(-this.state.marginLeft, -this.state.marginTop, canvas.width, canvas.height)\n    ctx.rect(-this.state.marginLeft, -this.state.marginTop, canvas.width, canvas.height)\n\n    if (this.props.showGrid) {\n      // ctx.fillStyle = drawGrid({ deltaX: this.state.scale, deltaY: this.state.scale, color: '#606060', scale: 100 })\n      // ctx.fill()\n\n      // ctx.fillStyle = drawGrid({deltaX: 1000, deltaY: 1000, color: 'black', scale: this.state.scale})\n      // ctx.fill()\n    }\n  }\n\n  drawObjects() {\n    const canvas = this.canvasRef.current\n    const ctx = canvas.getContext('2d')\n\n    // Draws all objects again\n    const objects = this.props.objects\n    for (let i = 0; i < objects.length; i++) {\n      const object = objects[i]\n\n      // Use \"some\" intelligence to know what's going on\n      if (isNumeric(object[0])) {\n        if (object.length >= 2 && isNumeric(object[1])) {\n          if (object.length >= 3 && isNumeric(object[2])) {\n            if (object.length >= 3 && isNumeric(object[3])) {\n              // 4 numeric values, so for me it is a 'poly' of 2 sides :D\n              object.unshift('poly')\n            } else {\n              // 3 numeric values, so for me it is a circle\n              object.unshift('c')\n            }\n          } else {\n            // 2 numeric values, so for me it is a point\n            object.unshift('p')\n          }\n        } else {\n          // idk what is this\n        }\n      }\n\n      // They especify the type\n      if (object.length < 3)\n        continue // not ready yet \n\n      const type = object[0]\n      const objectToDraw = { ctx, canvas, obj: object, scale: this.state.scale }\n\n      if (type.length > 1 && !type.endsWith(\"poly\")) {\n        // A text object\n        drawText(objectToDraw)\n        continue\n      }\n\n      switch (type[0]) {\n        case 'p':\n          if (type.endsWith(\"poly\"))\n            drawPolygon(objectToDraw)\n          else\n            drawPoint(objectToDraw)\n          break\n\n        case 'l':\n          drawLine(objectToDraw)\n          break\n\n        case 's':\n          drawSegment(objectToDraw)\n          break\n\n        case 'c':\n          drawCircle(objectToDraw)\n          break\n\n        default:\n          console.log(\"wtf bro!!\")\n          break\n      }\n    }\n\n    ctx.restore();\n  }\n\n  componentDidMount() {\n    this.prepareCanvas()\n  }\n\n  componentDidUpdate() {\n    if (this.props.restartScale) {\n      this.restartScale()\n      this.props.restartScaleDone()\n    }\n    this.prepareCanvas()\n    this.drawObjects()\n  }\n\n  zoomInOut(event) {\n    const deltaScale = 0.01\n\n    this.setState((prevState) => {\n      let newScale = prevState.scale + event.deltaY * -deltaScale\n      newScale = Math.min(500, Math.max(1, newScale))\n\n      return {\n        scale: newScale\n      }\n    })\n  }\n\n  onMouseUp(event) {\n    this.setState(() => {\n      return {\n        dragging: false\n      }\n    })\n  }\n\n  onMouseMove(event) {\n    const canvas = this.canvasRef.current\n    const ctx = canvas.getContext('2d')\n\n    this.setState((prevState) => {\n      let curState = prevState\n\n      if (curState.dragging) {\n        let deltaX = event.clientX - prevState.x\n        let deltaY = event.clientY - prevState.y\n\n        curState.marginLeft += deltaX\n        curState.marginTop += deltaY\n        ctx.translate(deltaX, deltaY)\n\n        curState.x = event.clientX\n        curState.y = event.clientY\n      }\n\n      return curState\n    })\n  }\n\n  onMouseDown(event) {\n    this.setState(() => {\n      return {\n        dragging: true,\n        x: event.clientX,\n        y: event.clientY,\n      }\n    })\n  }\n\n\n  render() {\n    return (\n      <>\n        <canvas\n          width=\"1000\" height=\"800\"\n          className=\"image\"\n          ref={this.canvasRef}\n          onWheel={this.zoomInOut.bind(this)}\n          onMouseDown={this.onMouseDown.bind(this)}\n          onMouseMove={this.onMouseMove.bind(this)}\n          onMouseUp={this.onMouseUp.bind(this)} />\n      </>\n    )\n  }\n}\n\nexport default Canvas\n\n\n","/Users/abraham/Geometry-drawing-tool/src/Geometry.js",["35","36"],"import {isNumeric, isColor, lightenColor} from \"./Stuff\";\n\nconst LineWidth = 0.4\nconst Smallest = 4\nconst Biggest = 5\n\nfunction getX(props) {\n  const { x, canvas, scale } = props\n  return scale * parseFloat(x) + canvas.width / 2\n}\n\nfunction getY(props) {\n  const { y, canvas, scale } = props\n  return -scale * parseFloat(y) + canvas.height / 2\n}\n\nexport function drawGrid(props) {\n  // This don't scale itself :c\n  const { deltaX, deltaY, color, scale } = props\n\n  const canvas = document.createElement(\"canvas\")\n  const ctx = canvas.getContext('2d')\n\n  canvas.width = deltaX\n  canvas.height = deltaY\n  // ctx.fillStyle = 'white'\n\n  ctx.strokeStyle = color\n  ctx.moveTo(0, 0);\n  ctx.lineTo(deltaX * scale, 0)\n  ctx.stroke()\n\n  ctx.moveTo(0, 0)\n  ctx.lineTo(0, deltaY * scale)\n  ctx.stroke()\n  return ctx.createPattern(canvas, 'repeat')\n}\n\nfunction drawTextAt(props) {\n  const { ctx, canvas, text, x, y, scale, color } = props\n\n  let fontSize = Math.min(20, Math.max(18, scale))\n\n  ctx.font = fontSize + \"px Comic Sans MS\";\n  ctx.fillStyle = color;\n  ctx.fillText(text, x + 10, y + 10);\n}\n\nexport function drawText(props) { \n  // Lets see how useful you are\n  const { ctx, canvas, obj, scale } = props\n\n  const text = \" \" + obj[0] + \" \"\n  const x = getX({ x: obj[1], canvas, scale })\n  const y = getY({ y: obj[2], canvas, scale })\n  const color = obj.length >= 4 ? obj[3] : 'black'\n\n  drawTextAt({ ctx, canvas, text, x, y, scale, color })\n}\n\nexport function drawPoint(props) {\n  // point x y color\n  // point x y text\n  // point x y color text\n  const { ctx, canvas, obj, scale } = props\n\n  if (obj.length < 3)\n    return\n\n  const x = getX({ x: obj[1], canvas, scale })\n  const y = getY({ y: obj[2], canvas, scale })\n\n  let color = 'black'\n  let text = \"\"\n  if (obj.length >= 4) {\n    if (isColor(obj[3])) {\n      color = obj[3]\n      if (obj.length >= 5)\n        text = obj[4]\n    } else {\n      text = obj[3]\n    }\n  } \n  \n  ctx.fillStyle = lightenColor(color);\n  ctx.strokeStyle = 'black';\n  ctx.beginPath()\n  const r = Math.max(Smallest, Math.min(Biggest, scale * LineWidth)) * 1.3\n  ctx.arc(x, y, r, 0, 2 * Math.PI)\n  ctx.fill()\n  \n  drawTextAt({ ctx, canvas, text, x, y, scale, color })\n}\n\nexport function drawLine(props) {\n  // line x1 y1 x2 y2 color\n  // line x1 y1 x2 y2 text\n  // line x1 y1 x2 y2 color text\n  const { ctx, canvas, obj, scale } = props\n\n  if (obj.length < 5)\n    return\n\n  const x1 = getX({ x: obj[1], canvas, scale })\n  const y1 = getY({ y: obj[2], canvas, scale })\n  const x2 = getX({ x: obj[3], canvas, scale })\n  const y2 = getY({ y: obj[4], canvas, scale })\n\n  let color = 'black'\n  let text = \"\"\n  if (obj.length >= 6) {\n    if (isColor(obj[5])) {\n      color = obj[5]\n      if (obj.length >= 7)\n        text = obj[6]\n    } else {\n      text = obj[5]\n    }\n  } \n\n  const inf = 100000\n  const k = Math.hypot(x2 - x1, y2 - y1)\n  const dirx = (x2 - x1) / k\n  const diry = (y2 - y1) / k\n\n  ctx.strokeStyle = lightenColor(color);\n  ctx.beginPath();\n  ctx.lineWidth = Math.max(Smallest, Math.min(Biggest, scale * LineWidth))\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x1 + dirx * inf, y1 + diry * inf);\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x1 - dirx * inf, y1 - diry * inf);\n  ctx.stroke()\n\n  drawTextAt({ ctx, canvas, text, x: (x1 + x2) / 2, y: (y1 + y2) / 2, scale, color })\n}\n\nexport function drawSegment(props) {\n  // seg x1 y1 x2 y2 color\n  const { ctx, canvas, obj, scale } = props\n\n  if (obj.length < 5)\n    return\n\n  const x1 = getX({ x: obj[1], canvas, scale })\n  const y1 = getY({ y: obj[2], canvas, scale })\n  const x2 = getX({ x: obj[3], canvas, scale })\n  const y2 = getY({ y: obj[4], canvas, scale })\n  \n  let color = 'black'\n  let text = \"\"\n  if (obj.length >= 6) {\n    if (isColor(obj[5])) {\n      color = obj[5]\n      if (obj.length >= 7)\n        text = obj[6]\n    } else {\n      text = obj[5]\n    }\n  } \n\n  ctx.strokeStyle = lightenColor(color);\n  ctx.beginPath();\n  ctx.lineWidth = Math.max(Smallest, Math.min(Biggest, scale * LineWidth))\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n  ctx.stroke()\n\n  drawTextAt({ ctx, canvas, text, x: (x1 + x2) / 2, y: (y1 + y2) / 2, scale, color })\n}\n\nexport function drawCircle(props) {\n  // circle x y radio color\n  // circle x y radio text\n  // circle x y radio color text\n  const { ctx, canvas, obj, scale } = props\n\n  if (obj.length < 4)\n    return\n\n  const x = getX({ x: obj[1], canvas, scale })\n  const y = getY({ y: obj[2], canvas, scale })\n  const r = scale * parseFloat(obj[3])\n\n  let color = 'black'\n  let text = \"\"\n  if (obj.length >= 5) {\n    if (isColor(obj[4])) {\n      color = obj[4]\n      if (obj.length >= 6)\n        text = obj[5]\n    } else {\n      text = obj[4]\n    }\n  }\n\n  ctx.strokeStyle = lightenColor(color);\n  ctx.beginPath()\n  ctx.lineWidth = Math.max(Smallest, Math.min(Biggest, scale * LineWidth))\n  ctx.arc(x, y, r, 0, 2 * Math.PI)\n  ctx.stroke()\n\n  drawTextAt({ ctx, canvas, text, x: x + r, y, scale, color })\n}\n\nexport function drawPolygon(props) {\n  // poly x1 y1 x2 y2 ... xn yn color \n  // poly x1 y1 x2 y2 ... xn yn text\n  // poly x1 y1 x2 y2 ... xn yn color text\n  const { ctx, canvas, obj, scale } = props\n\n  if (obj.length < 5)\n    return\n\n  const poly = []\n  let rightMost = { x: -100000000, y: -100000000 }\n  for (let i = 1; i < obj.length - 1; i += 2) \n    if (isNumeric(obj[i]) && isNumeric(obj[i + 1])) {\n      const x = getX({ x: obj[i], canvas, scale })\n      const y = getY({ y: obj[i + 1], canvas, scale })\n      poly.push({ x, y })\n      \n      if (x > rightMost.x)\n        rightMost = { x: x, y: y }\n    }\n\n  let color = 'black'\n  let text = \"\"\n  if (2 * poly.length + 1 < obj.length) {\n    if (isColor(obj[2 * poly.length + 1])) {\n      color = obj[2 * poly.length + 1]  // for sure its the color\n      if (obj.length - 1 != 2 * poly.length + 1) \n        text = obj[obj.length - 1] // text to write if isn't the color\n    } else {\n      text = obj[2 * poly.length + 1] // is it text?\n    }\n  }\n\n  ctx.strokeStyle = lightenColor(color);\n  ctx.lineWidth = Math.max(Smallest, Math.min(Biggest, scale * LineWidth))\n  for (let i = 0; i < poly.length; i++) {\n    ctx.fillStyle = color;\n    ctx.beginPath()\n    ctx.arc(poly[i].x, poly[i].y, 4, 0, 2 * Math.PI)\n    ctx.fill()\n\n    let j = (i + 1) % poly.length\n    ctx.beginPath();\n    ctx.moveTo(poly[i].x, poly[i].y);\n    ctx.lineTo(poly[j].x, poly[j].y);\n    ctx.stroke()\n  }\n\n  drawTextAt({ ctx, canvas, text, x: rightMost.x, y: rightMost.y, scale, color })\n}\n","/Users/abraham/Geometry-drawing-tool/src/Stuff.js",["37","38","39","40","41","42","43","44","45","46","47"],"export function isNumeric(num) {\n  return !isNaN(num)\n}\n\nexport function isColor(x){\n  let s = new Option().style\n  s.color = x\n  let test1 = s.color == x\n  let test2 = /^#[0-9A-F]{6}$/i.test(x)\n  return (test1 == true || test2 == true)\n}\n\nexport function isSpace(c) {\n  return (c == ' ') || (c == '\\t');\n}\n\nexport function divideByTokens(str) {\n  var result = [];\n  var last = \"\";\n  for (var i in str) {\n    var c = str[i];\n    if (isSpace(c)) {\n      if (last != \"\") {\n        result.push(last);\n      }\n      last = \"\";\n    } else {\n      last += c;\n    }\n  }\n  if (last != \"\") {\n    result.push(last);\n  }\n  return result;\n}\n\nfunction getRGB(v) {\n  var el = document.createElement(\"div\");\n  el.style[\"background-color\"] = v;\n  document.body.appendChild(el);\n\n  var style = window.getComputedStyle(el);\n  var color = style[\"backgroundColor\"];\n  document.body.removeChild(el);\n\n  return color;\n}\n\nfunction parseColor(color) {\n  var arr=[]; \n  color.replace(/[\\d+\\.]+/g, function(v) { \n    arr.push(parseFloat(v));\n  });\n  return \"#\" + arr.slice(0, 3).map(toHex).join(\"\");\n}\n\nfunction toHex(int) {\n  var hex = int.toString(16);\n  return hex.length == 1 ? \"0\" + hex : hex;\n}\n\nexport function lightenColor(col, amt = 40) {\n  if (col.charAt(0) != '#') {\n    col = parseColor(getRGB(col));\n  }\n  \n  var cur = col.charAt(0) == '#' ? col.substring(1, 7) : col;\n  \n  var r = Math.max(Math.min(255, parseInt(cur.substring(0, 2), 16) + amt), 0).toString(16)\n  var g = Math.max(Math.min(255, parseInt(cur.substring(2, 4), 16) + amt), 0).toString(16)\n  var b = Math.max(Math.min(255, parseInt(cur.substring(4, 6), 16) + amt), 0).toString(16)\n  \n  const rr = (r.length < 2 ? '0' : '') + r\n  const gg = (g.length < 2 ? '0' : '') + g\n  const bb = (b.length < 2 ? '0' : '') + b\n  return `#${rr}${gg}${bb}`\n}",{"ruleId":"48","replacedBy":"49"},{"ruleId":"50","replacedBy":"51"},{"ruleId":"52","severity":1,"message":"53","line":2,"column":8,"nodeType":"54","messageId":"55","endLine":2,"endColumn":16},{"ruleId":"56","severity":1,"message":"57","line":34,"column":20,"nodeType":"58","messageId":"59","endLine":34,"endColumn":22},{"ruleId":"56","severity":1,"message":"57","line":34,"column":32,"nodeType":"58","messageId":"59","endLine":34,"endColumn":34},{"ruleId":"56","severity":1,"message":"57","line":34,"column":44,"nodeType":"58","messageId":"59","endLine":34,"endColumn":46},{"ruleId":"56","severity":1,"message":"57","line":34,"column":56,"nodeType":"58","messageId":"59","endLine":34,"endColumn":58},{"ruleId":"52","severity":1,"message":"60","line":2,"column":20,"nodeType":"54","messageId":"55","endLine":2,"endColumn":28},{"ruleId":"52","severity":1,"message":"61","line":40,"column":16,"nodeType":"54","messageId":"55","endLine":40,"endColumn":22},{"ruleId":"56","severity":1,"message":"62","line":232,"column":26,"nodeType":"58","messageId":"59","endLine":232,"endColumn":28},{"ruleId":"56","severity":1,"message":"57","line":8,"column":23,"nodeType":"58","messageId":"59","endLine":8,"endColumn":25},{"ruleId":"56","severity":1,"message":"57","line":10,"column":17,"nodeType":"58","messageId":"59","endLine":10,"endColumn":19},{"ruleId":"56","severity":1,"message":"57","line":10,"column":34,"nodeType":"58","messageId":"59","endLine":10,"endColumn":36},{"ruleId":"56","severity":1,"message":"57","line":14,"column":13,"nodeType":"58","messageId":"59","endLine":14,"endColumn":15},{"ruleId":"56","severity":1,"message":"57","line":14,"column":27,"nodeType":"58","messageId":"59","endLine":14,"endColumn":29},{"ruleId":"56","severity":1,"message":"62","line":23,"column":16,"nodeType":"58","messageId":"59","endLine":23,"endColumn":18},{"ruleId":"56","severity":1,"message":"62","line":31,"column":12,"nodeType":"58","messageId":"59","endLine":31,"endColumn":14},{"ruleId":"63","severity":1,"message":"64","line":51,"column":22,"nodeType":"65","messageId":"66","endLine":51,"endColumn":23,"suggestions":"67"},{"ruleId":"56","severity":1,"message":"57","line":59,"column":21,"nodeType":"58","messageId":"59","endLine":59,"endColumn":23},{"ruleId":"56","severity":1,"message":"62","line":63,"column":21,"nodeType":"58","messageId":"59","endLine":63,"endColumn":23},{"ruleId":"56","severity":1,"message":"57","line":67,"column":27,"nodeType":"58","messageId":"59","endLine":67,"endColumn":29},"no-native-reassign",["68"],"no-negated-in-lhs",["69"],"no-unused-vars","'ReactDOM' is defined but never used.","Identifier","unusedVar","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'drawGrid' is defined but never used.","'canvas' is assigned a value but never used.","Expected '!==' and instead saw '!='.","no-useless-escape","Unnecessary escape character: \\..","Literal","unnecessaryEscape",["70","71"],"no-global-assign","no-unsafe-negation",{"messageId":"72","fix":"73","desc":"74"},{"messageId":"75","fix":"76","desc":"77"},"removeEscape",{"range":"78","text":"79"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"80","text":"81"},"Replace the `\\` with `\\\\` to include the actual backslash character.",[964,965],"",[964,964],"\\"]