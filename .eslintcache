[{"/Users/abraham/Geometry-drawing-tool/src/index.js":"1","/Users/abraham/Geometry-drawing-tool/src/App.js":"2","/Users/abraham/Geometry-drawing-tool/src/Canvas.js":"3","/Users/abraham/Geometry-drawing-tool/src/Geometry.js":"4"},{"size":152,"mtime":1610326722525,"results":"5","hashOfConfig":"6"},{"size":2342,"mtime":1611527730781,"results":"7","hashOfConfig":"6"},{"size":4154,"mtime":1611528382769,"results":"8","hashOfConfig":"6"},{"size":6489,"mtime":1611527590078,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},"1vvolej",{"filePath":"13","messages":"14","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"17","messages":"18","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"19","usedDeprecatedRules":"12"},"/Users/abraham/Geometry-drawing-tool/src/index.js",[],["20","21"],"/Users/abraham/Geometry-drawing-tool/src/App.js",["22","23","24","25","26","27"],"/Users/abraham/Geometry-drawing-tool/src/Canvas.js",[],"/Users/abraham/Geometry-drawing-tool/src/Geometry.js",["28","29","30","31","32"],"const LineWidth = 0.2\nconst Smallest = 3\nconst Biggest = 4\n\nfunction isNumeric(num) {\n  return !isNaN(num)\n}\n\nfunction isColor(x){\n  let s = new Option().style\n  s.color = x\n  let test1 = s.color == x\n  let test2 = /^#[0-9A-F]{6}$/i.test(x)\n  return (test1 == true || test2 == true)\n}\n\nfunction getX(props) {\n  const { x, canvas, scale } = props\n  return scale * parseFloat(x) + canvas.width / 2\n}\n\nfunction getY(props) {\n  const { y, canvas, scale } = props\n  return -scale * parseFloat(y) + canvas.height / 2\n}\n\nexport function drawGrid(props) {\n  // This don't scale itself :c\n  const { deltaX, deltaY, color, scale } = props\n\n  const canvas = document.createElement(\"canvas\")\n  const ctx = canvas.getContext('2d')\n\n  canvas.width = deltaX\n  canvas.height = deltaY\n  ctx.fillStyle = 'white'\n\n  ctx.strokeStyle = color\n  ctx.moveTo(0, 0);\n  ctx.lineTo(deltaX * scale, 0)\n  ctx.stroke()\n\n  ctx.moveTo(0, 0)\n  ctx.lineTo(0, deltaY * scale)\n  ctx.stroke()\n  return ctx.createPattern(canvas, 'repeat')\n}\n\nfunction drawTextAt(props) {\n  const { ctx, canvas, text, x, y, scale, color } = props\n\n  let fontSize = Math.min(20, Math.max(10, scale))\n\n  ctx.font = fontSize + \"px Comic Sans MS\";\n  ctx.fillStyle = color;\n  ctx.fillText(text, x + 5, y + 5);\n}\n\nexport function drawText(props) { \n  // Lets see how useful you are\n  const { ctx, canvas, obj, scale } = props\n\n  const text = \" \" + obj[0] + \" \"\n  const x = getX({ x: obj[1], canvas, scale })\n  const y = getY({ y: obj[2], canvas, scale })\n  const color = obj.length >= 4 ? obj[3] : 'black'\n\n  drawTextAt({ ctx, canvas, text, x, y, scale, color })\n}\n\nexport function drawPoint(props) {\n  // point x y color\n  // point x y text\n  // point x y color text\n  const { ctx, canvas, obj, scale } = props\n\n  if (obj.length < 3)\n    return\n\n  const x = getX({ x: obj[1], canvas, scale })\n  const y = getY({ y: obj[2], canvas, scale })\n\n  let color = 'black'\n  let text = \"\"\n  if (obj.length >= 4) {\n    if (isColor(obj[3])) {\n      color = obj[3]\n      if (obj.length >= 5)\n        text = obj[4]\n    } else {\n      text = obj[3]\n    }\n  } \n  \n  ctx.fillStyle = color;\n  ctx.strokeStyle = 'black';\n  ctx.beginPath()\n  const r = Math.max(Smallest, Math.min(Biggest, scale * LineWidth))\n  ctx.arc(x, y, r, 0, 2 * Math.PI)\n  ctx.fill()\n  \n  drawTextAt({ ctx, canvas, text, x, y, scale, color })\n}\n\nexport function drawLine(props) {\n  // line x1 y1 x2 y2 color\n  // line x1 y1 x2 y2 text\n  // line x1 y1 x2 y2 color text\n  const { ctx, canvas, obj, scale } = props\n\n  if (obj.length < 5)\n    return\n\n  const x1 = getX({ x: obj[1], canvas, scale })\n  const y1 = getY({ y: obj[2], canvas, scale })\n  const x2 = getX({ x: obj[3], canvas, scale })\n  const y2 = getY({ y: obj[4], canvas, scale })\n\n  let color = 'black'\n  let text = \"\"\n  if (obj.length >= 6) {\n    if (isColor(obj[5])) {\n      color = obj[5]\n      if (obj.length >= 7)\n        text = obj[6]\n    } else {\n      text = obj[5]\n    }\n  } \n\n  const dirx = x2 - x1\n  const diry = y2 - y1\n\n  ctx.strokeStyle = color;\n  ctx.beginPath();\n  ctx.lineWidth = Math.max(Smallest, Math.min(Biggest, scale * LineWidth)) / 2\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x1 + dirx * canvas.width, y1 + diry * canvas.height);\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x1 - dirx * canvas.width, y1 - diry * canvas.height);\n  ctx.stroke()\n\n  drawTextAt({ ctx, canvas, text, x: (x1 + x2) / 2, y: (y1 + y2) / 2, scale, color })\n}\n\nexport function drawSegment(props) {\n  // seg x1 y1 x2 y2 color\n  const { ctx, canvas, obj, scale } = props\n\n  if (obj.length < 5)\n    return\n\n  const x1 = getX({ x: obj[1], canvas, scale })\n  const y1 = getY({ y: obj[2], canvas, scale })\n  const x2 = getX({ x: obj[3], canvas, scale })\n  const y2 = getY({ y: obj[4], canvas, scale })\n  \n  let color = 'black'\n  let text = \"\"\n  if (obj.length >= 6) {\n    if (isColor(obj[5])) {\n      color = obj[5]\n      if (obj.length >= 7)\n        text = obj[6]\n    } else {\n      text = obj[5]\n    }\n  } \n\n  ctx.strokeStyle = color;\n  ctx.beginPath();\n  ctx.lineWidth = Math.max(Smallest, Math.min(Biggest, scale * LineWidth)) / 2\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n  ctx.stroke()\n\n  drawTextAt({ ctx, canvas, text, x: (x1 + x2) / 2, y: (y1 + y2) / 2, scale, color })\n}\n\nexport function drawCircle(props) {\n  // circle x y radio color\n  // circle x y radio text\n  // circle x y radio color text\n  const { ctx, canvas, obj, scale } = props\n\n  if (obj.length < 4)\n    return\n\n  const x = getX({ x: obj[1], canvas, scale })\n  const y = getY({ y: obj[2], canvas, scale })\n  const r = scale * parseFloat(obj[3])\n\n  let color = 'black'\n  let text = \"\"\n  if (obj.length >= 5) {\n    if (isColor(obj[4])) {\n      color = obj[4]\n      if (obj.length >= 6)\n        text = obj[5]\n    } else {\n      text = obj[4]\n    }\n  }\n\n  ctx.strokeStyle = color;\n  ctx.beginPath()\n  ctx.lineWidth = Math.max(Smallest, Math.min(Biggest, scale * LineWidth))\n  ctx.arc(x, y, r, 0, 2 * Math.PI)\n  ctx.stroke()\n\n  drawTextAt({ ctx, canvas, text, x: x + r, y, scale, color })\n}\n\nexport function drawPolygon(props) {\n  // poly x1 y1 x2 y2 ... xn yn color \n  // poly x1 y1 x2 y2 ... xn yn text\n  // poly x1 y1 x2 y2 ... xn yn color text\n  const { ctx, canvas, obj, scale } = props\n\n  if (obj.length < 5)\n    return\n\n  const poly = []\n  let rightMost = { x: -100000000, y: -100000000 }\n  for (let i = 1; i < obj.length - 1; i += 2) \n    if (isNumeric(obj[i]) && isNumeric(obj[i + 1])) {\n      const x = getX({ x: obj[i], canvas, scale })\n      const y = getY({ y: obj[i + 1], canvas, scale })\n      poly.push({ x, y })\n      \n      if (x > rightMost.x)\n        rightMost = { x: x, y: y }\n    }\n\n  let color = 'black'\n  let text = \"\"\n  if (2 * poly.length + 1 < obj.length) {\n    if (isColor(obj[2 * poly.length + 1])) {\n      color = obj[2 * poly.length + 1]  // for sure its the color\n      if (obj.length - 1 != 2 * poly.length + 1) \n        text = obj[obj.length - 1] // text to write if isn't the color\n    } else {\n      text = obj[2 * poly.length + 1] // is it text?\n    }\n  }\n\n  ctx.strokeStyle = color;\n  ctx.lineWidth = Math.max(Smallest, Math.min(Biggest, scale * LineWidth)) / 2\n  for (let i = 0; i < poly.length; i++) {\n    ctx.fillStyle = color;\n    ctx.beginPath()\n    ctx.arc(poly[i].x, poly[i].y, 4, 0, 2 * Math.PI)\n    ctx.fill()\n\n    let j = (i + 1) % poly.length\n    ctx.beginPath();\n    ctx.moveTo(poly[i].x, poly[i].y);\n    ctx.lineTo(poly[j].x, poly[j].y);\n    ctx.stroke()\n  }\n\n  drawTextAt({ ctx, canvas, text, x: rightMost.x, y: rightMost.y, scale, color })\n}\n",{"ruleId":"33","replacedBy":"34"},{"ruleId":"35","replacedBy":"36"},{"ruleId":"37","severity":1,"message":"38","line":2,"column":8,"nodeType":"39","messageId":"40","endLine":2,"endColumn":16},{"ruleId":"41","severity":1,"message":"42","line":34,"column":20,"nodeType":"43","messageId":"44","endLine":34,"endColumn":22},{"ruleId":"41","severity":1,"message":"42","line":34,"column":32,"nodeType":"43","messageId":"44","endLine":34,"endColumn":34},{"ruleId":"41","severity":1,"message":"42","line":34,"column":44,"nodeType":"43","messageId":"44","endLine":34,"endColumn":46},{"ruleId":"41","severity":1,"message":"42","line":34,"column":56,"nodeType":"43","messageId":"44","endLine":34,"endColumn":58},{"ruleId":"37","severity":1,"message":"45","line":38,"column":21,"nodeType":"39","messageId":"40","endLine":38,"endColumn":24},{"ruleId":"41","severity":1,"message":"42","line":12,"column":23,"nodeType":"43","messageId":"44","endLine":12,"endColumn":25},{"ruleId":"41","severity":1,"message":"42","line":14,"column":17,"nodeType":"43","messageId":"44","endLine":14,"endColumn":19},{"ruleId":"41","severity":1,"message":"42","line":14,"column":34,"nodeType":"43","messageId":"44","endLine":14,"endColumn":36},{"ruleId":"37","severity":1,"message":"46","line":50,"column":16,"nodeType":"39","messageId":"40","endLine":50,"endColumn":22},{"ruleId":"41","severity":1,"message":"47","line":240,"column":26,"nodeType":"43","messageId":"44","endLine":240,"endColumn":28},"no-native-reassign",["48"],"no-negated-in-lhs",["49"],"no-unused-vars","'ReactDOM' is defined but never used.","Identifier","unusedVar","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'pos' is assigned a value but never used.","'canvas' is assigned a value but never used.","Expected '!==' and instead saw '!='.","no-global-assign","no-unsafe-negation"]