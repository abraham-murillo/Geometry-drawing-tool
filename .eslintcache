[{"/Users/abraham/Geometry-drawing-tool/src/index.js":"1","/Users/abraham/Geometry-drawing-tool/src/App.js":"2","/Users/abraham/Geometry-drawing-tool/src/Canvas.js":"3","/Users/abraham/Geometry-drawing-tool/src/Geometry.js":"4","/Users/abraham/Geometry-drawing-tool/src/Stuff.js":"5"},{"size":152,"mtime":1640638000961,"results":"6","hashOfConfig":"7"},{"size":3051,"mtime":1640700000506,"results":"8","hashOfConfig":"7"},{"size":5390,"mtime":1640715933664,"results":"9","hashOfConfig":"7"},{"size":4949,"mtime":1640716004129,"results":"10","hashOfConfig":"7"},{"size":1681,"mtime":1640708374913,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"km15ib",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"19","usedDeprecatedRules":"14"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"22","messages":"23","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24","usedDeprecatedRules":"14"},"/Users/abraham/Geometry-drawing-tool/src/index.js",[],["25","26"],"/Users/abraham/Geometry-drawing-tool/src/App.js",[],"/Users/abraham/Geometry-drawing-tool/src/Canvas.js",["27"],"import React, { Component } from \"react\";\nimport { drawGrid, drawAllObjects } from \"./Geometry\";\nimport { isNumeric, isColor } from \"./Stuff\";\nimport \"./styles.css\"\n\nclass Canvas extends Component {\n  constructor(props) {\n    super(props)\n    this.canvasRef = React.createRef()\n\n    this.state = {\n      scale: 20,\n      dragging: false,\n      x: 0,\n      y: 0,\n      marginLeft: 0,\n      marginTop: 0,\n    }\n\n    this.restartScale = this.restartScale.bind(this)\n  }\n\n  restartScale() {\n    this.setState(() => {\n      return {\n        scale: 20,\n        dragging: false,\n      }\n    })\n  }\n\n  goToOrigin() { }\n\n  prepareCanvas(first) {\n    const canvas = this.canvasRef.current\n    const ctx = canvas.getContext('2d')\n\n    ctx.clearRect(-this.state.marginLeft, -this.state.marginTop, canvas.width, canvas.height)\n\n    ctx.fillStyle = '#f6f6fc'\n    ctx.fillRect(-this.state.marginLeft, -this.state.marginTop, canvas.width, canvas.height)\n    ctx.rect(-this.state.marginLeft, -this.state.marginTop, canvas.width, canvas.height)\n\n    if (this.props.showGrid) {\n      ctx.fillStyle = drawGrid(10, 10, '#606060', this.state.scale)\n      ctx.fill()\n\n      // ctx.fillStyle = drawGrid(100, 100, 'black', this.state.scale)\n      // ctx.fill()\n    }\n  }\n\n  mergePolygonPoints(rawObjects) {\n    const objects = []\n    for (const cur of rawObjects) {\n      const prev = objects[objects.length - 1]\n\n      if (cur.length == 0) {\n        // next one is a new object\n        objects.push(cur)\n        continue\n      }\n\n      if (objects.length > 0 && prev.length > 0 && prev[0].startsWith(\"poly\")) {\n        objects[objects.length - 1] = prev.concat(cur)\n      } else {\n        objects.push(cur)\n      }\n    }\n\n    return objects\n  }\n\n  assignObjectsType(rawObjects) {\n    // Use \"some\" intelligence to know what's going on\n    return rawObjects.map((cur) => {\n      if (cur.length && isNumeric(cur[0])) {\n        if (cur.length >= 2 && isNumeric(cur[1])) {\n          if (cur.length >= 3 && isNumeric(cur[2])) {\n            if (cur.length >= 4 && isNumeric(cur[3])) {\n              // 4 numeric values, so for me it is a 'poly' of 2 sides :D\n              cur.unshift('poly')\n            } else {\n              // 3 numeric values, so for me it is a circle\n              cur.unshift('circle')\n            }\n          } else {\n            // 2 numeric values, so for me it is a point\n            cur.unshift('point')\n          }\n        } else {\n          // idk what is this, just 1 value .-.\n        }\n      }\n\n      return cur\n    }).filter((cur) => {\n      return cur.length > 0\n    })\n  }\n\n  setAsObjects(rawObjects) {\n    const objects = []\n\n    let currentColor = \"black\"\n    for (const cur of rawObjects) {\n      if (isColor(cur[0])) {\n        currentColor = cur[0]\n        continue\n      }\n\n      if (cur.length < 3) {\n        // object not ready yet \n        continue\n      }\n\n      const object = {\n        type: cur[0],\n        color: currentColor,\n        arr: [],\n        scale: this.state.scale,\n        text: \"\",\n      }\n\n      for (let i = 1; i < cur.length; i++) {\n        if (isColor(cur[i])) {\n          object.color = cur[i]\n        } else if (isNumeric(cur[i])) {\n          object.arr.push(cur[i])\n        } else {\n          object.text += \" \" + cur[i]\n        }\n      }\n\n      objects.push(object)\n    }\n\n    return objects\n  }\n\n  drawObjects() {\n    const canvas = this.canvasRef.current\n    const ctx = canvas.getContext('2d')\n\n    // Draws all objects again\n    let objects = this.mergePolygonPoints(this.props.objects)\n    objects = this.assignObjectsType(objects)\n    objects = this.setAsObjects(objects)\n\n    drawAllObjects(ctx, canvas, objects)\n  }\n\n  componentDidMount() {\n    this.prepareCanvas(true)\n  }\n\n  componentDidUpdate() {\n    if (this.props.restartScale) {\n      this.restartScale()\n      this.props.restartScaleDone()\n    }\n    if (this.props.goToOrigin) {\n      this.goToOrigin()\n      this.props.goToOriginDone()\n    }\n    this.prepareCanvas(false)\n    this.drawObjects()\n  }\n\n  zoomInOut(event) {\n    const deltaScale = 0.01\n\n    this.setState((prevState) => {\n      let newScale = prevState.scale + event.deltaY * -deltaScale\n      newScale = Math.min(500, Math.max(1, newScale))\n\n      return {\n        scale: newScale\n      }\n    })\n  }\n\n  onMouseUp(event) {\n    this.setState({ dragging: false })\n  }\n\n  onMouseMove(event) {\n    const canvas = this.canvasRef.current\n    const ctx = canvas.getContext('2d')\n\n    this.setState((prevState) => {\n      let curState = prevState\n\n      if (curState.dragging) {\n        let deltaX = event.clientX - prevState.x\n        let deltaY = event.clientY - prevState.y\n\n        curState.marginLeft += deltaX\n        curState.marginTop += deltaY\n        ctx.translate(deltaX, deltaY)\n\n        curState.x = event.clientX\n        curState.y = event.clientY\n      }\n\n      return curState\n    })\n  }\n\n  onMouseDown(event) {\n    this.setState({\n      dragging: true,\n      x: event.clientX,\n      y: event.clientY,\n    })\n  }\n\n  render() {\n    // console.log(this.props);\n\n    return (\n      <canvas\n        width=\"1000\" height=\"800\"\n        className=\"image\"\n        ref={this.canvasRef}\n        onWheel={this.zoomInOut.bind(this)}\n        onMouseDown={this.onMouseDown.bind(this)}\n        onMouseMove={this.onMouseMove.bind(this)}\n        onMouseUp={this.onMouseUp.bind(this)}\n      />\n    )\n  }\n}\n\nexport default Canvas\n\n\n","/Users/abraham/Geometry-drawing-tool/src/Geometry.js",["28"],"/Users/abraham/Geometry-drawing-tool/src/Stuff.js",["29"],"export function isNumeric(num) {\n  return !isNaN(num)\n}\n\nexport function isColor(x) {\n  let s = new Option().style\n  s.color = x\n  let test1 = s.color === x\n  let test2 = /^#[0-9A-F]{6}$/i.test(x)\n  return (test1 === true || test2 === true)\n}\n\nexport function isSpace(c) {\n  return (c === ' ') || (c === '\\t');\n}\n\nexport function divideByTokens(str) {\n  let result = [];\n  let last = \"\";\n  for (let i in str) {\n    let c = str[i];\n    if (isSpace(c)) {\n      if (last !== \"\") {\n        result.push(last);\n      }\n      last = \"\";\n    } else {\n      last += c;\n    }\n  }\n  if (last !== \"\") {\n    result.push(last);\n  }\n  return result;\n}\n\nfunction getRGB(v) {\n  let el = document.createElement(\"div\");\n  el.style[\"background-color\"] = v;\n  document.body.appendChild(el);\n\n  let style = window.getComputedStyle(el);\n  let color = style[\"backgroundColor\"];\n  document.body.removeChild(el);\n\n  return color;\n}\n\nfunction parseColor(color) {\n  let arr = [];\n  color.replace(/[\\d+\\.]+/g, function (v) {\n    arr.push(parseFloat(v));\n  });\n  return \"#\" + arr.slice(0, 3).map(toHex).join(\"\");\n}\n\nfunction toHex(int) {\n  let hex = int.toString(16);\n  return hex.length === 1 ? \"0\" + hex : hex;\n}\n\nexport function lightenColor(color, amt = 30) {\n  if (color.charAt(0) !== '#') {\n    color = parseColor(getRGB(color));\n  }\n\n  let cur = color.charAt(0) === '#' ? color.substring(1, 7) : color;\n\n  let r = Math.max(Math.min(255, parseInt(cur.substring(0, 2), 16) + amt), 0).toString(16)\n  let g = Math.max(Math.min(255, parseInt(cur.substring(2, 4), 16) + amt), 0).toString(16)\n  let b = Math.max(Math.min(255, parseInt(cur.substring(4, 6), 16) + amt), 0).toString(16)\n\n  return `#${r}${g}${b}`\n}",{"ruleId":"30","replacedBy":"31"},{"ruleId":"32","replacedBy":"33"},{"ruleId":"34","severity":1,"message":"35","line":58,"column":22,"nodeType":"36","messageId":"37","endLine":58,"endColumn":24},{"ruleId":"38","severity":1,"message":"39","line":1,"column":21,"nodeType":"40","messageId":"41","endLine":1,"endColumn":28},{"ruleId":"42","severity":1,"message":"43","line":51,"column":22,"nodeType":"44","messageId":"45","endLine":51,"endColumn":23,"suggestions":"46"},"no-native-reassign",["47"],"no-negated-in-lhs",["48"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-unused-vars","'isColor' is defined but never used.","Identifier","unusedVar","no-useless-escape","Unnecessary escape character: \\..","Literal","unnecessaryEscape",["49","50"],"no-global-assign","no-unsafe-negation",{"messageId":"51","fix":"52","desc":"53"},{"messageId":"54","fix":"55","desc":"56"},"removeEscape",{"range":"57","text":"58"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"59","text":"60"},"Replace the `\\` with `\\\\` to include the actual backslash character.",[973,974],"",[973,973],"\\"]